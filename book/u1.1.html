<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> Adversarial Search and Games  - uniexam</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="syllabi.html">Syllabi</a></li><li class="chapter-item expanded "><a href="ai.html"><strong aria-hidden="true">1.</strong> Artificial Intelligence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u1.1.html" class="active"><strong aria-hidden="true">1.1.</strong>  Adversarial Search and Games </a></li><li class="chapter-item expanded "><a href="u1.2.html"><strong aria-hidden="true">1.2.</strong>  Knowledge </a></li><li class="chapter-item expanded "><a href="u1.3.html"><strong aria-hidden="true">1.3.</strong>  Reasoning </a></li><li class="chapter-item expanded "><a href="u1.4.html"><strong aria-hidden="true">1.4.</strong>  Planning </a></li><li class="chapter-item expanded "><a href="ai_prelim.html"><strong aria-hidden="true">1.5.</strong>  Questions </a></li></ol></li><li class="chapter-item expanded "><a href="cc.html"><strong aria-hidden="true">2.</strong> Cloud Computing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u2.1.html"><strong aria-hidden="true">2.1.</strong> Virtualization in Cloud Computing</a></li><li class="chapter-item expanded "><a href="u2.2.html"><strong aria-hidden="true">2.2.</strong> Cloud Platforms and Cloud Applications</a></li><li class="chapter-item expanded "><a href="u2.3.html"><strong aria-hidden="true">2.3.</strong> Security in Cloud Computing</a></li><li class="chapter-item expanded "><a href="u2.4.html"><strong aria-hidden="true">2.4.</strong> Advanced Techniques in Cloud Computing</a></li><li class="chapter-item expanded "><a href="cc_prelim.html"><strong aria-hidden="true">2.5.</strong>  Questions </a></li></ol></li><li class="chapter-item expanded "><a href="dsbda.html"><strong aria-hidden="true">3.</strong> Data Science and Big Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u3.1.html"><strong aria-hidden="true">3.1.</strong> Big Data Analytics Life Cycle</a></li><li class="chapter-item expanded "><a href="u3.2.html"><strong aria-hidden="true">3.2.</strong> Predictive Big Data Analytics with Python</a></li><li class="chapter-item expanded "><a href="u3.3.html"><strong aria-hidden="true">3.3.</strong> Big Data Analytics and Model Evaluation</a></li><li class="chapter-item expanded "><a href="u3.4.html"><strong aria-hidden="true">3.4.</strong> Data Visualization and Hadoop</a></li><li class="chapter-item expanded "><a href="dsbda_prelim.html"><strong aria-hidden="true">3.5.</strong>  Questions </a></li></ol></li><li class="chapter-item expanded "><a href="wt.html"><strong aria-hidden="true">4.</strong> Web Technologies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u4.1.html"><strong aria-hidden="true">4.1.</strong> Java Servlets and XML</a></li><li class="chapter-item expanded "><a href="u4.2.html"><strong aria-hidden="true">4.2.</strong> JSP and Web Services</a></li><li class="chapter-item expanded "><a href="u4.3.html"><strong aria-hidden="true">4.3.</strong> Server Side Scripting Languages</a></li><li class="chapter-item expanded "><a href="u4.4.html"><strong aria-hidden="true">4.4.</strong> Ruby and Rails</a></li><li class="chapter-item expanded "><a href="wt_prelim.html"><strong aria-hidden="true">4.5.</strong>  Questions </a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">uniexam</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unit-iii-adversarial-search-and-games"><a class="header" href="#unit-iii-adversarial-search-and-games">Unit III: Adversarial Search and Games</a></h1>
<h2 id="game-theory"><a class="header" href="#game-theory">Game Theory</a></h2>
<p>For MCQs:</p>
<p>States where the game has ended are called <strong>terminal states.</strong></p>
<p>&quot;zero-sum” means that what is good for one player is just as bad for the other:
there is <strong>no “win-win”</strong> outcome. A <strong>utility function</strong> is also called an
<strong>objective function or payoff function.</strong></p>
<p>Chess is considered a “zero-sum” game,</p>
<p>Game tree is also known as Search tree or space graph</p>
<p>Notes:</p>
<p>Definition</p>
<p>Game Theory tries to understand the strategic moves of the players and deicide
the optimal move from the set of all possible moves. To achieve this it makes
use of game tree. A game tree is a recursive search function that examines all
possible moves and their results and then decide the optimal move.</p>
<p>Working:</p>
<p>Start at the current board position,</p>
<p>Check all the possible moves the player can make</p>
<p>From each possible move predict which move the opponent will play</p>
<p>Decide the optimal move based on opponents move and results.</p>
<p>The two players and usually named as MAX and MIN.</p>
<p>MAX moves first, and then the players take turns moving until the game is over</p>
<p>At the end of the game, points are awarded to the winning player and penalties
are given to the loser</p>
<p>A game can be formally defined with the following elements:</p>
<p><strong>Initial state</strong>, which specifies how the game is set up at the start.</p>
<p><strong>TO-MOVE</strong> : The player whose turn it is to move in state</p>
<p><strong>ACTIONS</strong> : The set of legal moves in state</p>
<p><strong>RESULT</strong> : The transition model, which defines the state resulting from taking
action</p>
<p>in state .</p>
<p><strong>TERMINAL</strong> : States where the game has ended are called terminal states.</p>
<p><strong>UTILITY FUNCTION</strong> : A utility function defines the final numeric value to
player when the game ends in terminal state</p>
<p>MCQs to solve:</p>
<p><a href="https://engineeringinterviewquestions.com/mcqs-on-game-theory-and-answers/">https://engineeringinterviewquestions.com/mcqs-on-game-theory-and-answers/
</a><a href="https://www.sanfoundry.com/artificial-intelligence-mcqs-game-theory-1/">https://www.sanfoundry.com/artificial-intelligence-mcqs-game-theory-1/</a></p>
<p>Videos to watch :</p>
<p><a href="https://www.youtube.com/watch?v=FFzdXJ49KAI">Introduction to Game Playing in Artificial Intelligence | Learn Game Playing
Algorithms with Example</a></p>
<h2 id="optimal-decisions-in-games"><a class="header" href="#optimal-decisions-in-games">Optimal Decisions in Games</a></h2>
<p>MIN MAX ALGO</p>
<p>In artificial intelligence, minimax is a<strong>decision-making</strong> strategy under<strong>game
theory,</strong> which is used to minimize the losing chances in a game and to maximize
the winning chances. This strategy is also known as ‘<strong>Minmax,’ ’MM,’ or ‘Saddle
point.’</strong></p>
<p>We can easily understand this strategy via <strong>game tree</strong>- where the <em>nodes
represent the states of the game and edges represent the moves made by the
players in the game</em>. Players will be two namely:</p>
<ul>
<li><strong>MIN:</strong> Decrease the chances of <strong>MAX</strong> to win the game.</li>
<li><strong>MAX:</strong> Increases his chances of winning the game.</li>
</ul>
<p>They both play the game alternatively, i.e., turn by turn and following the
above strategy, i.e., if one wins, the other will definitely lose it.</p>
<p>In minimax strategy, the result of the game or the utility value is generated by
a<strong>heuristic function</strong> by propagating from the initial node to the root node.
It follows the<strong>backtracking technique</strong> and backtracks to find the best choice.
MAX will choose that path which will increase its utility value and MIN will
choose the opposite path which could help it to minimize MAX’s utility value.</p>
<p>MINIMAX algorithm is a backtracking algorithm where it backtracks to pick the
best move out of several choices. MINIMAX strategy follows the <strong>DFS (Depth-
first search)</strong> concept. Here, we have two players <strong>MIN and MAX,</strong> and the game
is played alternatively between them, i.e., when <strong>MAX</strong> made a move, then the
next turn is of <strong>MIN.</strong> It means the move made by MAX is fixed and, he cannot
change it. The same concept is followed in DFS strategy, i.e., we follow the
same path and cannot change in the middle. That’s why in MINIMAX algorithm,
instead of BFS, we follow DFS.</p>
<ul>
<li>Keep on generating the game tree/ search tree till a limit <strong>d.</strong></li>
<li>Compute the move using a heuristic function.</li>
<li>Propagate the values from the leaf node till the current position following
the minimax strategy.</li>
<li>Make the best move from the choices.</li>
</ul>
<p>For example, in the above figure, the two players <strong>MAX</strong> and <strong>MIN</strong> are</p>
<p>there. <strong>MAX</strong> starts the game by choosing one path and propagating all the
nodes of that path. Now, <strong>MAX</strong> will backtrack to the initial node and choose
the best path where his utility value will be the maximum. After this,</p>
<p>its <strong>MIN</strong> chance. <strong>MIN</strong> will also propagate through a path and again will
backtrack, but <strong>MIN</strong> will choose the path which could minimize <strong>MAX</strong> winning
chances or the utility value.</p>
<p><em><strong>So, if the level is minimizing, the node will accept the minimum value from
the successor nodes. If the level is maximizing, the node will accept the
maximum value from the successor.</strong></em></p>
<p><strong>Note</strong>: The time complexity of MINIMAX algorithm is <strong>O(bd)</strong> where b is the
branching factor and d is the depth of the search tree.</p>
<p><img src="pics/004.png" alt="" /></p>
<p>For example, in the above figure, the two players <strong>MAX</strong> and <strong>MIN</strong> are</p>
<p>there. <strong>MAX</strong> starts the game by choosing one path and propagating all the
nodes of that path. Now, <strong>MAX</strong> will backtrack to the initial node and choose
the best path where his utility value will be the maximum. After this,</p>
<p>its <strong>MIN</strong> chance. <strong>MIN</strong> will also propagate through a path and again will
backtrack, but <strong>MIN</strong> will choose the path which could minimize <strong>MAX</strong> winning
chances or the utility value.</p>
<p><em><strong>So, if the level is minimizing, the node will accept the minimum value from
the successor nodes. If the level is maximizing, the node will accept the
maximum value from the successor.</strong></em></p>
<p><strong>Note</strong>: The time complexity of MINIMAX algorithm is <strong>O(bd)</strong> where b is the
branching factor and d is the depth of the search tree.</p>
<p><img src="pics/005.jpeg" alt="" /></p>
<h2 id="heuristic-alpha-beta-tree-search"><a class="header" href="#heuristic-alpha-beta-tree-search">Heuristic Alpha Beta Tree Search</a></h2>
<p>Alpha-beta pruning is an advance version of MINIMAX algorithm. The drawback of
minimax strategy is that it explores each node in the tree deeply to provide the
best path among all the paths. This increases its time complexity. But as we
know, the performance measure is the first consideration for any optimal
algorithm. Therefore, alpha-beta pruning reduces this drawback of minimax
strategy by less exploring the nodes of the search tree.</p>
<p>The method used in alpha-beta pruning is that it <strong>cutoff the search</strong> by
exploring less number of nodes. It makes the same moves as a minimax algorithm
does, but it prunes the unwanted branches using the pruning technique</p>
<p><strong>Working of Alpha-beta Pruning</strong></p>
<p>Consider the below example of a game tree where <strong>P</strong> and <strong>Q</strong> are two players.
The game will be played alternatively, i.e., chance by chance. Let, <strong>P</strong> be the
player who will try to win the game by maximizing its winning chances.  <strong>Q</strong> is
the player who will try to minimize **P’**s winning chances. Here, <strong>?</strong>
will represent the maximum value of the nodes, which will be the value for <strong>P</strong>
as well. <strong>?</strong> will represent the minimum value of the nodes, which will be the
value of <strong>Q</strong>.</p>
<p><img src="pics/006.jpeg" alt="" /></p>
<ul>
<li>Any one player will start the game. Following the DFS order, the player will
choose one path and will reach to its depth, i.e., where he will find</li>
</ul>
<p>the <strong>TERMINAL</strong> value.</p>
<ul>
<li>If the game is started by player P, he will choose the maximum value in
order to increase its winning chances with maximum utility value.</li>
<li>If the game is started by player Q, he will choose the minimum value in
order to decrease the winning chances of A with the best possible minimum
utility value.</li>
<li>Both will play the game alternatively.</li>
<li>The game will be started from the last level of the game tree, and the value
will be chosen accordingly.</li>
<li>Like in the below figure, the game is started by player Q. He will pick the
leftmost value of the TERMINAL and fix it for beta (?). Now, the next
TERMINAL value will be compared with the ?-value. If the value will be
smaller than or equal to the ?-value, replace it with the current ?-value
otherwise no need to replace the value.</li>
<li>After completing one part, move the achieved ?-value to its upper node and
fix it for the other threshold value, i.e., ?.</li>
<li>Now, its P turn, he will pick the best maximum value. P will move to explore
the next part only after comparing the values with the current ?-value. If
the value is equal or greater than the current ?-value, then only it will be
replaced otherwise we will prune the values.</li>
<li>The steps will be repeated unless the result is not obtained.</li>
<li>So, number of pruned nodes in the above example are <strong>four</strong> and MAX wins
the</li>
</ul>
<p>game with the maximum <strong>UTILITY</strong> value, i.e.,<strong>3</strong></p>
<p>The rule which will be followed is: <strong>“Explore nodes if necessary otherwise
prune the unnecessary nodes.”</strong></p>
<p><strong>Note:</strong> It is obvious that the result will have the same <strong>UTILITY</strong> value
that we may get from the MINIMAX strategy.</p>
<h2 id="monte-carlo-tree-search"><a class="header" href="#monte-carlo-tree-search">Monte Carlo Tree Search</a></h2>
<p>It is a probabilistic and heuristic driven search algorithm</p>
<p>The basic MCTS strategy does not use a heuristic evaluation function. Instead,
the value of a state is estimated as the average utility over a number of
simulations of complete games starting from the state. A simulation (also called
a playout or rollout) chooses moves first</p>
<p>for one player, than for the other, repeating until a terminal position is
reached. At that point the rules of the game (not fallible heuristics)
determine who has won or lost, and by what score. For games in which the only
outcomes are a win or a loss, “average utility” is the same as “win
percentage.”</p>
<p>pure Monte Carlo search, is to do N simulations starting from the current state
of the game, and track which of the possible moves from the current position has
the highest win percentage.</p>
<p>It balances two factors:</p>
<p>exploration of states that have had few playouts, and exploitation of states
that have done well in past playouts, to get a more accurate estimate of their
value.</p>
<p>Monte Carlo tree search does that by</p>
<p>maintaining a search tree and growing it on each iteration of the following four
steps:</p>
<p>SELECTION: Starting at the root of the search tree, we choose a move (guided by
the selection policy), leading to a successor node, and repeat that process,
moving down the tree to a leaf.</p>
<p>EXPANSION: We grow the search tree by generating a new child of the selected
node; SIMULATION: We perform a playout from the newly generated child node,
choosing moves for both players according to the playout policy. These moves are
not recorded in the search tree.</p>
<p>BACK-PROPAGATION: We now use the result of the simulation to update all the</p>
<p>search tree nodes going up to the root.</p>
<p><img src="pics/007.jpeg" alt="" /></p>
<p><strong>Advantages of Monte Carlo Tree Search:</strong></p>
<ol>
<li>MCTS is a simple algorithm to implement.</li>
<li>Monte Carlo Tree Search is a heuristic algorithm. MCTS can operate
effectively without any knowledge in the particular domain, apart from the rules
and end conditions, and can can find its own moves and learn from them by
playing random playouts.</li>
<li>The MCTS can be saved in any intermediate state and that state can be used
in future use cases whenever required.</li>
<li>MCTS supports asymmetric expansion of the search tree based on the
circumstances in which it is operating.</li>
</ol>
<p><strong>Disadvantages of Monte Carlo Tree Search:</strong></p>
<ol start="5">
<li>As the tree growth becomes rapid after a few iterations, it requires a huge
amount of memory.</li>
<li>There is a bit of a reliability issue with Monte Carlo Tree Search. In
certain scenarios, there might be a single branch or path, that might lead to
loss against the opposition when implemented for those turn-based games. This is
mainly due to the vast amount of combinations and each of the nodes might not be
visited enough number of times to understand its result or outcome in the long
run.</li>
<li>MCTS algorithm needs a huge number of iterations to be able to effectively
decide the most efficient path. So, there is a bit of a speed issue there.</li>
</ol>
<h2 id="stochastic-games"><a class="header" href="#stochastic-games">Stochastic Games</a></h2>
<p>Stochastic games are simulations of dynamic interactions in which the
environment changes in response to the activities of the participants. &quot;In a
stochastic game, the play progresses by steps from position to position,
according to transition probabilities determined jointly by the two players,&quot;
Shapley writes.</p>
<p>A group of participants participates in a stochastic game. At each stage of the
game, the action takes place in a specific state (or position, in Shapley's
terminology), and each player selects an action from a list of options. The
stage payoff that each player receives is determined by the collection of
actions that the players choose, as well as the current state, as well as a
probability distribution for the subsequent state that the game will visit.</p>
<p>Stochastic games apply von Neumann's model of strategic-form games to dynamic
settings in which the environment varies in response to the players' decisions.
They also use the Markov decision problem model, which was created by numerous
RAND Corporation researchers in 1949–1952, to competitive scenarios with
multiple decision makers.</p>
<p>The complexity of stochastic games arises from the fact that the players'
decisions have two, sometimes opposing, consequences. First, the players'
actions, in combination with the present state, determine the immediate payment
that each player receives. Second, the present state and the players' activities
influence the next state selection, which influences future reward
possibilities. Each player, in particular, must balance these factors when
deciding on his actions, which might be a difficult decision. Although this
dichotomy is also present in one-player sequential decision problems, the
presence of additional players who maximize their own goals adds complexity to
the analysis of the situation.</p>
<ul>
<li>
<p><strong>Two player Games:</strong> For modelling and analysis of discrete systems
functioning in an uncertain (adversarial) environment, stochastic two-player
games on directed graphs are commonly employed. As vertices, a system's and
its environment's possible configurations are represented, and transitions
correspond to the system's, its environment's, or &quot;nature's&quot; actions. An
infinite path in the graph corresponds to a run of the system. As a result,
a system and its environment can be viewed as two hostile players, with one
player (the system) aiming to maximise the probability of &quot;good&quot; runs and
the other player (the environment) aiming to maximise the chance of &quot;bad&quot;
runs. Although there may be an equilibrium value for this probability in
many circumstances, there may not be optimal solutions for both parties. We
go over some of the fundamental notions and algorithmic concerns that have
been studied in this field, as well as some long-standing outstanding
difficulties. Then we'll go through a few recent findings.</p>
</li>
<li>
<p><strong>Application:</strong> Economic theory, evolutionary biology, and computer
networks all use stochastic games. They are generalisations of repeated
games that correspond to the unique case of a single state.</p>
</li>
<li>
<p><strong>Key takeaway:</strong> Stochastic games are simulations of dynamic interactions
in which the environment changes in response to the activities of the
participants. &quot;In a stochastic game, the play progresses by steps from
position to position, according to transition probabilities determined
jointly by the two players,&quot; Shapley writes.</p>
</li>
</ul>
<h2 id="partially-observable-games"><a class="header" href="#partially-observable-games">Partially Observable Games</a></h2>
<p>In deterministic partially observable games, uncertainty about the state of the
board arises entirely from lack of access to the choices made by the opponent.</p>
<p>For a partially observable</p>
<p>game, the notion of a strategy is altered; instead of specifying a move to make
for each possible move the opponent might make, we need a move for every
possible percept sequence that might be received.</p>
<p>Card games such as bridge, whist, hearts, and poker feature stochastic partial
observability, where the missing information is generated by the random dealing
of cards.</p>
<p>treat the start of the game as a chance node with every possible deal as an</p>
<p>outcome, and then use the EXPECTIMINIMAX formula to pick the best move.</p>
<h2 id="limitations-in-game-search-algorithm"><a class="header" href="#limitations-in-game-search-algorithm">Limitations in game search algorithm</a></h2>
<p>Alpha–beta search uses the heuristic</p>
<p>evaluation function as an approximation</p>
<p>Monte Carlo search computes an approximate</p>
<p>average over a random selection of playouts.</p>
<p>when the branching factor is high or it is difficult to</p>
<p>define an evaluation function, Monte Carlo search is preferred</p>
<p>One limitation of alpha–beta search is its vulnerability to errors in the
heuristic function.</p>
<p>A second limitation of both alpha–beta and Monte Carlo is that they are designed
to calculate (bounds on) the values of legal moves. But sometimes there is one
move that is obviously best (for example when there is only one legal move), and
in that case, there is no point wasting computation time to figure out the value
of the move</p>
<p>A third limitation is that both alpha-beta and Monte Carlo do all their
reasoning at the level of individual moves.</p>
<h2 id="constraint-satisfaction-problems"><a class="header" href="#constraint-satisfaction-problems">Constraint satisfaction problems</a></h2>
<p>Constraint satisfaction is a technique where a problem is solved when its values
satisfy certain constraints or rules of the problem.</p>
<p>The main idea is to eliminate large portions of the search space all at once by
identifying variable/value combinations that violate the constraints.</p>
<p>A constraint satisfaction problem consists of three components, and : X is a set
of variables, {X1,….Xn}</p>
<p>D is a set of domains, , {D1,.......Dn}, one for each variable.</p>
<p>C is a set of constraints that specify allowable combinations of values.</p>
<p>Where,</p>
<p>X is a set of variables.</p>
<p>D consists of a set of allowable values for each variable</p>
<p>For example, a Boolean variable would have the domain {true, false} .</p>
<p>C is constraint</p>
<p>Each constraint consists of a pair ,<em>(scope, rel)</em> where <em>scope</em> is a tuple of
variables that participate in the constraint and <em>rel</em> is a relation that
defines the values that those variables can take on.</p>
<p>An assignment of values to a variable can be done in three ways:</p>
<p><strong>Consistent or Legal Assignment:</strong></p>
<p>An assignment which does not violate any constraint or rule is called Consistent
or legal assignment.</p>
<p><strong>Complete Assignment:</strong></p>
<p>An assignment where every variable is assigned with a value, and the solution to
the CSP remains consistent. Such assignment is known as Complete assignment.</p>
<p><strong>Partial Assignment:</strong></p>
<p>An assignment which assigns values to some of the variables only. Such type of
assignments are called Partial assignments.</p>
<p><strong>Partial Solution is a partial assignment that is consistent.</strong></p>
<p><strong>Why formulate a problem as a CSP?</strong></p>
<ol>
<li>CSPs yield a natural representation for a wide variety of problems; it is
often easy to formulate a problem as a CSP.</li>
<li>Years of development work have gone into making CSP solvers fast and
efficient.</li>
<li>a CSP solver can quickly prune large swathes of the search space that an
atomic state-space searcher cannot</li>
</ol>
<p>MCQs</p>
<p>MCQs</p>
<p>The 8-queens problem can also be viewed as a finite-domain CSP. Constraint Types
in CSP</p>
<p>Unary Constraint :</p>
<p>restricts the value of a single variable. For example, in the map-coloring
problem it could be the case that South Australians won’t tolerate the color
green; we can express that with the unary Constraint.</p>
<p>Binary Constraint :</p>
<p>A binary constraint relates two variables. For example, is a binary constraint.
A binary CSP is one with only unary and binary constraints; it can be
represented as a constraint graph.</p>
<p>Global Constraints:</p>
<p>It is the constraint type which involves an arbitrary number of variables.</p>
<h2 id="inference-in-csps"><a class="header" href="#inference-in-csps">Inference in CSPs</a></h2>
<p>Inference is nothing but reaching conclusion or achieving result on the basis of
evidence and reasoning.</p>
<p>In local state-spaces, the choice is only one, i.e., to search for a solution.
But in CSP, we have two choices either:</p>
<p>We can search for a solution or</p>
<p>We can perform a special type of inference called constraint propagation.</p>
<p>Constraint propagation is a special type of inference which helps in reducing
the legal number of values for the variables. The idea behind constraint
propagation is local consistency.</p>
<p>If we treat each variable as a node in a graph  and each binary constraint as an
edge, then the process of enforcing local consistency in each part of the graph
causes inconsistent values to be eliminated throughout the graph. There are
different types of local consistency Namely</p>
<p>Node Consistency:</p>
<p>A single variable (corresponding to a node in the CSP graph) is node-consistent
if all the values in the variable’s domain satisfy the variable’s unary
constraints.</p>
<p>It is easy to eliminate all the unary constraints in a CSP by reducing the
domain of variables with unary constraints at the start of the solving process.</p>
<p>Arc Consistency:</p>
<p>A variable in a CSP is arc-consistent if every value in its domain satisfies the
variable’s binary constraints</p>
<p>The most popular algorithm for enforcing arc consistency is called AC-3 (see
Figure 6.3 ). To make every variable arc-consistent, the AC-3 algorithm
maintains a queue of arcs to consider.</p>
<p>Path Consistency:</p>
<p>When the evaluation of a set of two variable with respect to a third variable
can be extended over another variable, satisfying all the binary constraints. It
is similar to arc consistency.</p>
<p>k-consistency:</p>
<p>Stronger forms of propagation can be defined with the notion of -consistency. A
CSP is - consistent if, for any set of variables and for any consistent
assignment to those variables, a consistent value can always be assigned to any
th variable</p>
<h2 id="backtracking-search-for-csps"><a class="header" href="#backtracking-search-for-csps">Backtracking search for CSPs</a></h2>
<p>The minimum-remaining-values and degree heuristics are domain-independent</p>
<p>methods for deciding which variable to choose next in a backtracking search. The
least constraining- value heuristic helps in deciding which value to try first
for a given</p>
<p>variable. Backtracking occurs when no legal assignment can be found for a
variable. Conflict-directed backjumping backtracks directly to the source of the
problem.</p>
<p>Constraint learning records the conflicts as they are encountered during search
in order</p>
<p>to avoid the same conflict later in the search.</p>
<p>The complexity of solving a CSP is strongly related to the structure of its
constraint</p>
<p>graph. Tree-structured problems can be solved in linear time.</p>
<p>Cutset conditioning can reduce a general CSP to a tree-structured one and is
quite efficient (requiring only linear</p>
<p>memory) if a small cutset can be found.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ai.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="u1.2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ai.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="u1.2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
