<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> Knowledge  - uniexam</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="syllabi.html">Syllabi</a></li><li class="chapter-item expanded "><a href="ai.html"><strong aria-hidden="true">1.</strong> Artificial Intelligence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u1.1.html"><strong aria-hidden="true">1.1.</strong>  Adversarial Search and Games </a></li><li class="chapter-item expanded "><a href="u1.2.html" class="active"><strong aria-hidden="true">1.2.</strong>  Knowledge </a></li><li class="chapter-item expanded "><a href="u1.3.html"><strong aria-hidden="true">1.3.</strong>  Reasoning </a></li><li class="chapter-item expanded "><a href="u1.4.html"><strong aria-hidden="true">1.4.</strong>  Planning </a></li><li class="chapter-item expanded "><a href="ai_prelim.html"><strong aria-hidden="true">1.5.</strong>  Questions </a></li></ol></li><li class="chapter-item expanded "><a href="cc.html"><strong aria-hidden="true">2.</strong> Cloud Computing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u2.1.html"><strong aria-hidden="true">2.1.</strong> Virtualization in Cloud Computing</a></li><li class="chapter-item expanded "><a href="u2.2.html"><strong aria-hidden="true">2.2.</strong> Cloud Platforms and Cloud Applications</a></li><li class="chapter-item expanded "><a href="u2.3.html"><strong aria-hidden="true">2.3.</strong> Security in Cloud Computing</a></li><li class="chapter-item expanded "><a href="u2.4.html"><strong aria-hidden="true">2.4.</strong> Advanced Techniques in Cloud Computing</a></li><li class="chapter-item expanded "><a href="cc_prelim.html"><strong aria-hidden="true">2.5.</strong>  Questions </a></li></ol></li><li class="chapter-item expanded "><a href="dsbda.html"><strong aria-hidden="true">3.</strong> Data Science and Big Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u3.1.html"><strong aria-hidden="true">3.1.</strong> Big Data Analytics Life Cycle</a></li><li class="chapter-item expanded "><a href="u3.2.html"><strong aria-hidden="true">3.2.</strong> Predictive Big Data Analytics with Python</a></li><li class="chapter-item expanded "><a href="u3.3.html"><strong aria-hidden="true">3.3.</strong> Big Data Analytics and Model Evaluation</a></li><li class="chapter-item expanded "><a href="u3.4.html"><strong aria-hidden="true">3.4.</strong> Data Visualization and Hadoop</a></li><li class="chapter-item expanded "><a href="dsbda_prelim.html"><strong aria-hidden="true">3.5.</strong>  Questions </a></li></ol></li><li class="chapter-item expanded "><a href="wt.html"><strong aria-hidden="true">4.</strong> Web Technologies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="u4.1.html"><strong aria-hidden="true">4.1.</strong> Java Servlets and XML</a></li><li class="chapter-item expanded "><a href="u4.2.html"><strong aria-hidden="true">4.2.</strong> JSP and Web Services</a></li><li class="chapter-item expanded "><a href="u4.3.html"><strong aria-hidden="true">4.3.</strong> Server Side Scripting Languages</a></li><li class="chapter-item expanded "><a href="u4.4.html"><strong aria-hidden="true">4.4.</strong> Ruby and Rails</a></li><li class="chapter-item expanded "><a href="wt_prelim.html"><strong aria-hidden="true">4.5.</strong>  Questions </a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">uniexam</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unit-iv-knowledge"><a class="header" href="#unit-iv-knowledge">Unit IV: <strong>Knowledge</strong></a></h1>
<h2 id="knowledge-based-agents"><a class="header" href="#knowledge-based-agents">Knowledge Based Agents</a></h2>
<p>knowledge-based agents use a process of reasoning over an internal
representation of</p>
<p>knowledge to decide what actions to take. Knowledge-based agent uses some
task-specific knowledge to solve a problem efficiently.</p>
<p>Knowledge-based agents can accept</p>
<p>new tasks in the form of explicitly described goals; they can achieve competence
quickly by</p>
<p>being told or learning new knowledge about the environment; and they can adapt
to</p>
<p>changes in the environment by updating the relevant knowledge.</p>
<p>the representation of knowledge is done via logics.</p>
<p>There are three main components of logic, which are as follows:</p>
<p>Syntax: It is the sequence of a specific language which should be followed in
order to form a sentence. Syntax is the representation of a  language. Every
language has its own syntax.</p>
<p>For example, ax2+bx+c is a well-formed syntax of a quadratic equation.</p>
<p>Semantics: The sentence or the syntax which a logic follows should be
meaningful. Semantics defines the sense of the sentence which relates to the
real world.</p>
<p>For example, Indian people celebrate Diwali every year. This sentence represents
the true fact about the country and its people who are Indians.</p>
<p>Each sentence is expressed in a language called a knowledge representation
language and</p>
<p>represents some assertion about the world.</p>
<p>When the sentence is taken as being given</p>
<p>without being derived from other sentences, we call it an axiom.</p>
<p>A knowledge-based system comprises of two distinguishable features which are:</p>
<p>A Knowledge base</p>
<p>An Inference Engine</p>
<p>Knowledge base: A Knowledge base represents the actual facts which exist in the
real world. It is the central component of a knowledge-based agent. It is a set
of sentences which describes the information related to the world.</p>
<p>Note: Here, a sentence is not an English language sentence, but it is
represented in a language known as Knowledge representation language.</p>
<p>Inference Engine: It is the engine of a knowledge-based system which allows to
infer new knowledge in the system.</p>
<p>There must be a way to add new sentences to the knowledge base and a way to
query what is known. The standard names for these operations are TELL and ASK,
respectively.</p>
<p>When the agent solves a problem, it calls the agent program each time. The agent
program performs three things:</p>
<p>It TELLS the knowledge base what it has perceived from the environment.</p>
<p>It ASKS the knowledge base about the actions it should take?</p>
<p>It TELLS the action which is chosen, and finally, the agent executes that
action.</p>
<p><img src="pics/008.png" alt="" /></p>
<p><img src="pics/009.png" alt="" /></p>
<p>These functions create an interface between the two main components of an
intelligent agent, i.e., sensors and actuators.</p>
<p><img src="pics/010.png" alt="" /></p>
<p>The functions are discussed below:</p>
<p>MAKE-PERCEPT-SENTENCE()</p>
<p>This function returns a sentence which tells the perceived information by the
agent at a given time.</p>
<p>MAKE-ACTION-QUERY()</p>
<p>This function returns a sentence which tells what action the agent must take at
the current time.</p>
<p>MAKE-ACTION-SENTENCE()</p>
<p>This function returns a sentence which tells an action is selected as well as
executed.</p>
<h2 id="wumpus-word"><a class="header" href="#wumpus-word">Wumpus Word</a></h2>
<p>The Wumpus world is a game playing which provides an environment to the
knowledge-based agent to showcase its stored knowledge. It was developed by
<strong>Gregory Yob</strong> in 1973.</p>
<p>About the game:</p>
<ul>
<li>It is a single-player game.</li>
<li>It is a cave consisting of rooms which are connected with one-another via
passways.</li>
<li>There is a beast or monster in the game named <strong>Wumpus,</strong> lurking somewhere
the cave.</li>
<li>Wumpus eats everyone who tries to enter the cave.</li>
<li>The player needs to kill the Wumpus.</li>
<li>The player has only one arrow to shoot out the monster.</li>
<li>There are some rooms containing <strong>bottomless pits</strong> which may trap anyone
whoever wanders in the room.</li>
<li>The goal of the game is <strong>to search for a heap of gold</strong>.</li>
</ul>
<p><img src="pics/011.png" alt="" /></p>
<p>PEAS Description of the Wumpus World</p>
<ul>
<li><strong>Performance Measure:</strong> The player is awarded with the following utilities:</li>
<li><strong>(+1000):</strong> It is for coming out of the cave safely with the gold.</li>
<li><strong>(-1000):</strong> It is for falling into the pit or if eaten by the Wumpus.</li>
<li><strong>(-1):</strong> It is for each action taken by the player.</li>
<li><strong>(-10):</strong> It is for raising the arrow up.</li>
</ul>
<p>The game ends if the player comes out of the cave safely or dies.</p>
<ol>
<li><strong>Environment:</strong> The environment provided in the Wumpus world is as follows:</li>
</ol>
<ul>
<li>It is a 4X4 grid of rooms.</li>
<li>The player always starts in the square labeled [1,1] and facing towards the
right.</li>
<li>Location of the monster and the gold is choosen randomly in a uniform
distribution.</li>
<li>Remember, the location chosen will never be the starting point.</li>
<li>Each square room other than the starting one can be a pit with 0.2</li>
</ul>
<p>probability.</p>
<ol start="2">
<li><strong>Actuators:</strong> The player performs the following actions:</li>
</ol>
<ul>
<li>The agent can move forward or TurnLeft by 900 and TurnRight by 900.</li>
<li>The player dies if he enters a room having a pit or alive monster. It is
safe to enter the room if the Wumpus is dead.</li>
<li>If the player will try to move forward and bumps into the wall, then the
player will not move.</li>
<li>Using the action <em><strong>Grab</strong></em>, the player can pick up the gold in the same
room.</li>
<li>Using the action <em><strong>Shoot</strong></em>, the player can shoot the monster with the
arrow. Either the arrow will shoot the monster or will hit on the wall.</li>
<li>The action <em><strong>Climb</strong></em> is used to come out of the cave but only from the
square</li>
</ul>
<p>[1,1].</p>
<ol start="3">
<li><strong>Sensors:</strong> The player is provided with five sensors, which gives a single
bit of information:</li>
</ol>
<ul>
<li>The player will perceive a <em><strong>Stench</strong></em>, if Wumpus is present in the room
which is directly adjacent to the player.</li>
<li>The player will perceive a <em><strong>Breeze</strong></em>, if in the square is directly
adjacent to the pit.</li>
<li>The player will perceive a <em><strong>Glitter</strong></em>, if in the square gold is present.</li>
<li>The player will perceive a <em><strong>Bump</strong></em>, when the player walks into the wall.</li>
</ul>
<p>When the player will shoot out the monster, it will emit a scary <em><strong>Scream</strong></em>
which can be heard/perceived from anywhere in the cave.</p>
<p>in each case for which the agent draws a conclusion from the available</p>
<p>information, that conclusion is guaranteed to be correct if the available
information is correct. This is a fundamental property of logical reasoning</p>
<h2 id="logic"><a class="header" href="#logic">Logic</a></h2>
<p>A logic is a formal language that allows sound inference and has well defined
syntax and semantics. There are various logics that allow you to represent
various types of things and allow for more or less efficient inference.
Different varieties of logic exist, such as propositional logic, predicate
logic, temporal logic, and description logic. However, expressing something in
logic may not be natural, and conclusions may be ineffective.</p>
<ul>
<li>
<p>Example of logic Language of numerical constraints:</p>
</li>
<li>
<p>A sentence: x + 3 ≤ z x, z - variable symbols (primitives in the language)</p>
</li>
<li>
<p>An interpretation: I: x = 5, z = 2</p>
</li>
</ul>
<p>Variables mapped to specific real numbers</p>
<ul>
<li>
<p>Valuation (meaning) function V: V (x + 3 ≤ z, I) is False for I: x = 5, z =
2 Is True for I: x = 5, z = 10</p>
</li>
<li>
<p>Types of logic:</p>
<ul>
<li>Different types of logics possible</li>
<li>Propositional logic</li>
<li>First-order logic</li>
<li>Temporal logic</li>
<li>Numerical constraints logic</li>
<li>Map-coloring logic</li>
</ul>
</li>
<li>
<p><strong>Key takeaway:</strong></p>
<ul>
<li>A logic is a formal language, with precisely defined syntax and
semantics, which supports sound inference.</li>
<li>The logic may be different types like propositional logic, predicate
logic, temporal logic, description logic etc.</li>
</ul>
</li>
</ul>
<h2 id="propositional-logic-a-very-simple-logic"><a class="header" href="#propositional-logic-a-very-simple-logic">Propositional Logic: A Very Simple Logic,</a></h2>
<p><strong>Syntax:</strong> The statements given in a problem are represented via propositional
symbols. Each sentence consists of a single propositional symbol. The
propositional symbol begins with an uppercase letter and may be followed by some
other subscripts or letters. We have two fixed propositional symbols, i.e., True
and False.</p>
<p>Complex sentences are constructed from simpler sentences, using parentheses and</p>
<p>operators called logical connectives. There are five connectives in common use:</p>
<ul>
<li><strong>not(¬):</strong> It is known as the <strong>negation</strong> of a sentence. A literal can be
a positive literal or a negative literal.</li>
<li><strong>and(^):</strong> When a sentence is having <strong>(^)</strong> as the main connective. It is
known</li>
</ul>
<p>as <strong>Conjunction,</strong> and its parts are known as <strong>Conjuncts</strong>. For example, <strong>(Y1
^ Y2) ? (Y3 ^ Y4) ? …(Yn ^ Ym),</strong> such type of sentences are known as
<strong>Conjunctive sentences</strong>.</p>
<ul>
<li><strong>or(V):</strong> When a sentence is having <strong>(V)</strong> as the main connective. It is
known as <strong>Disjunction,</strong> and its parts are known as <strong>Disjuncts</strong>. For
example, <strong>(Y1 ? Y2) V (Y3 ? Y4) V …(Yn ? Ym),</strong> such type of sentences are
known as <strong>Disjunctive sentences</strong>.</li>
<li><strong>implies(=&gt;):</strong> When <strong>(Y1 V Y2) =&gt; Y3</strong> is given, it is known as the
<strong>Implication of a sentence</strong>. It is like <strong>if-&gt;then</strong> clause, where if this
implies then it will happen. Implication is sometimes referred to as <strong>Rules
or if-then</strong> statement. It can also be d<strong>eno</strong>ted as (      ) or (       ).</li>
<li><strong>if and only if (<strong>ó</strong>):</strong> It represents implication at both sides where
the expression is <strong>(a1 V a2)</strong>?<strong>a3</strong>,. Such type of connective is called
<strong>biconditional implication</strong>. It returns true if both sides satisfy one
another, else returns false.This can also be denoted as (?).</li>
</ul>
<p><strong>Precedence Order of the Connectives</strong></p>
<p><img src="pics/012.png" alt="" /></p>
<p><strong>There are following five rules regarding the semantics of the complex
sentences P and Q in a given model m :</strong></p>
<p><strong>¬P:</strong> Its value will be false, iff it is true in the model m.</p>
<p><strong>(P ? Q):</strong> Its value is true, iff both P and Q are true in m.</p>
<p><strong>(P v Q):</strong> Its value is true, iff either P is true, or Q is true in m.</p>
<p><strong>(P=&gt; Q):</strong> Its value is true, iff the value of P is false, and that of Q is
true in m.</p>
<p><strong>(P ? Q):</strong> The value will be true, iff P and Q value is either true or false
in the given <strong>(P ? Q):</strong> The value will be true, iff P and Q value is either
true or false in the given model m.</p>
<p><strong>Note:</strong> Here, iff means if and only if.</p>
<p><img src="pics/013.jpeg" alt="" /></p>
<h2 id="propositional-theorem-proving"><a class="header" href="#propositional-theorem-proving">Propositional Theorem Proving</a></h2>
<p>Theorem proving—applying rules of inference directly to the sentences in our
knowledge base to construct a proof of the desired sentence without consulting
models.</p>
<p>Logical equivalence means two sentences and are logically equivalent if they are
true in the same set of models.</p>
<p><img src="pics/014.jpeg" alt="" /></p>
<p>A sentence is valid if it is true in all models. For</p>
<p>example, the sentence P ∨ ¬P is valid. Valid sentences are also known as
tautologies—they are necessarily true.</p>
<p>A sentence is satisfiable if it is true in, or  satisfied by, some model.</p>
<p><img src="pics/015.jpeg" alt="" /></p>
<h2 id="effective-propositional-model-checking"><a class="header" href="#effective-propositional-model-checking">Effective Propositional Model Checking</a></h2>
<p>Not so important topic according to me. Choosing to ignore this one.</p>
<h2 id="agents-based-on-propositional-logic"><a class="header" href="#agents-based-on-propositional-logic">Agents Based on Propositional Logic</a></h2>
<p><em>skipped</em></p>
<h2 id="first-order-logic"><a class="header" href="#first-order-logic">First Order Logic</a></h2>
<p>First-order logic is also called first-order predicate calculus; it may be
abbreviated as FOL or FOPC.</p>
<p>In predicate logic, the input is taken as an entity, and the output it gives is
either true or false.</p>
<p><strong>Elements and their symbols in Predicate Logic</strong></p>
<ul>
<li><strong>Objects:</strong> It refers to an entity that exists in the real world. <strong>For
example,</strong> Ram, John, etc. are referred to as Objects.</li>
<li><strong>Functions:</strong> Any function performed by the object/on the object. <strong>For</strong></li>
</ul>
<p><strong>example,</strong> LeftLeg, writes, eats, etc. are some of the functions.</p>
<ul>
<li><strong>Relations:</strong> The relation of an object with the other object defines its
relation**. For example,** brother, mother, king, etc. are some types of
relations which exist in the real world.</li>
</ul>
<p><strong>The symbols used to represent these elements. They are as follows:</strong></p>
<ul>
<li><strong>Constant Symbols:</strong> These symbols are used to represent the objects.</li>
<li><strong>Predicate Symbols:</strong> These symbols are used to represent relations.</li>
<li><strong>Function Symbols:</strong> These symbols are used to represent the functions
performed by the object.</li>
</ul>
<p>Some examples follow:</p>
<p>“One plus two equals three.” Objects: one, two, three, one plus two; Relation:
equals; Function: plus. (“One plus two” is a name for the object that is
obtained by applying the function “plus” to the objects “one” and “two.” “Three”
is another name for this object.) “Squares neighboring the wumpus are smelly.”
Objects: wumpus, squares; Property: smelly; Relation: neighboring.</p>
<p>“Evil King John ruled England in 1200.” Objects: John, England, 1200; Relation:
ruled during; Properties: evil, king.</p>
<p>The primary difference between propositional and first-order logic</p>
<p>Propositional logic assumes</p>
<p>that there are facts that either hold or do not hold in the world. Each fact can
be in one of two states—true or false—and each model assigns true or false to
each proposition symbol. First-order logic assumes more; namely, that the world
consists of</p>
<p>objects with certain relations among them that do or do not hold.</p>
<h2 id="representation-revisited"><a class="header" href="#representation-revisited">Representation Revisited</a></h2>
<p>Programming languages (such as C++, Java, and Lisp) are by far the most widely
used formal languages.</p>
<p>This procedural method contrasts with propositional logic's declarative
character, in which knowledge and inference are separated and inference is
domain- independent.</p>
<p>They lack the expressiveness required to deal with incomplete data.</p>
<ul>
<li>Using disjunction and negation, propositional logic has enough expressive
capability to deal with partial knowledge.</li>
<li>Compositionality is a third characteristic of propositional logic that is
useful in representation languages.</li>
</ul>
<p>The meaning of a sentence in a compositional language is determined by the
meaning of its constituent elements.</p>
<p>For example, ―S1,4 ^ S1,2‖ is related to the meanings of ―S1,4‖ and ―S1,2‖.</p>
<p>Propositional logic lacks the expressive power to succinctly explain a complex
environment with numerous items.</p>
<p>For example, we were compelled to establish a distinct regulation for each
square regarding breezes and pits, such as: <code>B 1,1⇔(P 1,2 or P 2,1)</code></p>
<p>In English, though, it seems simple enough to state unequivocally that squares
near to pits are airy.</p>
<p>Natural languages are also non-compositional, in the sense that the meaning of a
statement like &quot;Then she saw it&quot; might be influenced by the context created by
numerous preceding and following sentences.</p>
<p>Finally, natural languages contain ambiguity, which can make thinking harder.</p>
<p>The following are the most obvious features of natural language syntax:</p>
<ul>
<li>Object-referential nouns and noun phrases ( squares , pits, wumpuses ).</li>
<li>Verbs and verb phrases that allude to object relationships (is breezy, is
adjacent to, shoots).</li>
<li>Some of these relationships are functions, meaning they have only one value
for each input. It's simple to start a list of objects, relations, and
functions:</li>
</ul>
<p>Objects: People, houses, numbers, theories, Ronald McDonald, colors, baseball
games, wars, centuries….</p>
<p>Relation: These can be unary relations or properties like red, round, bogus,
prime, multi-storied............, or more general n-ary relations like brother
of, bigger than, within, part of, has colour, happened after, owns, comes
between, etc.</p>
<p>Functions: father of, closest friend, third inning of, more than, and the start
of.</p>
<ul>
<li>The first-order logic language has a syntax and semantics based on objects
and relations.</li>
<li>First-order logic can also be used to convey facts about some or all of the
universe's items.</li>
<li>This allows generic laws or norms to be represented, such as the sentence
&quot;Squares adjacent to the Wumpus are stinky.&quot;</li>
</ul>
<p>The ontological commitment made by each language—that is, what it assumes about
the nature of reality—is the basic difference between propositional and first-
order logic.</p>
<ul>
<li>Propositional logic, for example, assumes that there are facts in the world
that either hold or do not hold. There are two possible states for each
fact: true or untrue.</li>
<li>Temporal logic assumes that facts are true at specific moments and that
those times (which can be points or intervals) are in chronological
sequence. Higher-order logic considers the first-order logic's relations and
functions to be objects in and of themselves. This enables claims to be made
about all object relations. A talent for dealing with logical notation is
required of an AI student.</li>
</ul>
<p><img src="pics/representation_revisited.png" alt="Representation Revisited" /></p>
<h2 id="syntax-and-semantics-of-first-order"><a class="header" href="#syntax-and-semantics-of-first-order">Syntax and Semantics of First Order</a></h2>
<p><strong>Syntax:</strong> It defines the way of representing the given predicates. As these
predicates are represented via quantifiers, there are different types of
quantifiers used:</p>
<ul>
<li><strong>Universal Quantifier(For all/every):</strong> When the predicate is indicating
about all/everything, we use <strong>for all</strong> quantifier. It is denoted as <strong>&quot; ?
&quot;</strong></li>
<li><strong>Existential Quantifier(For some):</strong> When the predicate is indicating about
some quantity, we use <strong>for some</strong> quantifier. It is denoted as <strong>“?”</strong></li>
<li><strong>Nested Quantifiers:</strong> It is the nesting of the same type of quantifier.
One predicate is nested under the other predicate.</li>
<li><strong>Atomic Sentences:</strong> These sentences are formed via predicate symbols</li>
</ul>
<p>may or may not be followed by a list of terms.</p>
<p><strong>Example:</strong> Parents(Ram, Sita) where Ram and Sita are the parents.</p>
<ul>
<li><strong>Complex Sentences:</strong> These sentences make use of logical connectives to
construct more complex sentences.</li>
<li><strong>Equality:</strong> We use the equality symbol to express that two terms refer to
the same object**. For example,** Eleveenth_President(India)= Dr. APJ
Abdul Kalam. Here, both LHS is equal to RHS. It means that both terms refer
to the same entity/ person.</li>
</ul>
<p><strong>Semantics:</strong> It defines the sense of the given predicate. It allows to make
more logical expression by devising its semantics. Semantics allow us to
understand the sentence meaning.</p>
<p><strong>Let’s understand Predicate logic with the help of below examples: Example 1:</strong>
Lipton is a tea.</p>
<p><strong>Solution:</strong> Here, the object is Lipton.</p>
<p>It will be represented as <strong>Tea(Lipton).</strong></p>
<p><strong>Note:</strong> In this example, there is no requirement of quantifiers because the
quantity is not specified in the given predicate. <strong>Let’s see more.</strong></p>
<p><strong>Example 2:</strong> Every man is mortal.</p>
<p><strong>Solution:</strong> Here, the quantifier is the universal identifier, and the object
is man. Let x be the man.</p>
<p>Thus, it will be represented as <strong>x: man(x)  ? mortal(x).</strong></p>
<p><strong>Example 3:</strong> All girls are beautiful.</p>
<p><strong>Solution:</strong> Here, we are talking about all girls. It means universal
quantifier will be used. The object is girls. Let, y be the girls.</p>
<p>Therefore, it will be represented as <strong>girls(y) ? beautiful(y).</strong></p>
<p><strong>Example 4:</strong> All that glitters is not gold.</p>
<p><strong>Solution:</strong> Here, we will represent gold as x.</p>
<p>Therefore, it will be represented as <strong>glitters(x) ? ¬gold(x).</strong></p>
<h2 id="using-first-order-logic"><a class="header" href="#using-first-order-logic">Using First Order Logic</a></h2>
<p>Again not an important topic</p>
<h2 id="knowledge-engineering"><a class="header" href="#knowledge-engineering">Knowledge Engineering</a></h2>
<p>Process of knowledge base construction in called knowledge engineering.</p>
<p>a knowledge engineer investigates a specific domain, learn the important
concepts regarding that domain, and creates the formal representation of the
objects and relations in that domain.</p>
<p>There are 7 steps in knowledge engineering:</p>
<p><img src="pics/016.png" alt="" /></p>
<ol>
<li>IDENTIFY THE QUESTIONS</li>
</ol>
<ul>
<li>A knowledge engineer should be able to identify the task by asking a few
questions like:</li>
<li>Do the knowledge base will support?</li>
<li>What kinds of facts will be available for each specific problem?</li>
</ul>
<p>The task will identify the knowledge requirement needed to connect the problem
instance with the answers.</p>
<p>instance with the answers.</p>
<ol start="2">
<li>ASSEMBLE THE RELEVANT KNOWLEDGE</li>
</ol>
<ul>
<li>A knowledge engineer should be an expert in the domain. If not, he should
work with the real experts to extract their knowledge. This concept is</li>
</ul>
<p>known as <strong>Knowledge Acquisition</strong>.</p>
<p><strong>Note:</strong> Here, we do not represent the knowledge formally. But to understand
the scope of the knowledge base and also to understand the working of the
domain.</p>
<p>For the wumpus world, which is defined by an artificial set of rules, the
relevant</p>
<p>knowledge is easy to identify.</p>
<ol start="3">
<li>DECIDE ON A VOCABULARY OF PREDICATES, FUNCTIONS, AND CONSTANTS.</li>
</ol>
<ul>
<li>Translating important domain-level concepts into logical level concepts.
<strong>Here, the knowledge engineer asks questions like:</strong></li>
<li>What are the elements which should be represented as objects?</li>
<li>What functions should be chosen?</li>
</ul>
<p>After satisfying all the choices, the vocabulary is decided.</p>
<ol start="4">
<li>ENCODE GENERAL KNOWLEDGE ABOUT THE DOMAIN</li>
</ol>
<ul>
<li>In this step, the knowledge engineer pen down the axioms for all the chosen</li>
</ul>
<p>vocabulary terms.</p>
<p><strong>Note:</strong> Here, misconceptions occur between the vocabulary terms.</p>
<p>•</p>
<ul>
<li><strong>Encode description of the specific problem instance:</strong> We write the simple
atomic sentences for the selected vocabulary terms. We encode the chosen
problem instances.</li>
<li><strong>Raise queries to the inference procedure and get answers:</strong> It is the
testing step. We apply the inference procedure on those axioms and
problem-specific facts which we want to know.</li>
<li><strong>Debug the knowledge base:</strong> It is the last step of the knowledge
engineering process where the knowledge engineer debugs all the errors.</li>
</ul>
<h2 id="propositional-vs-first-order-inference"><a class="header" href="#propositional-vs-first-order-inference">Propositional vs First order Inference</a></h2>
<p>One way to do first-order inference is to convert the first-order knowledge base
to propositional logic and use propositional inference. first step is
eliminating universal quantifiers.</p>
<p><img src="pics/017.png" alt="" /></p>
<p><img src="pics/pro_vs_fo.png" alt="Propositional vs First order Inference" /></p>
<h2 id="knowledge-engineering-in-first-order-logic-inference-is-used-in-first-order"><a class="header" href="#knowledge-engineering-in-first-order-logic-inference-is-used-in-first-order">Knowledge Engineering in First-Order Logic Inference is used in First-Order</a></h2>
<p>Logic to generate new facts or sentences from current ones. It's crucial to
understand some basic FOL terms before diving into the FOL inference rule.</p>
<ul>
<li>
<p><strong>Substitution:</strong> Substitution is a fundamental approach for modifying
phrases and formulations. All first-order logic inference systems contain
it. The substitution becomes more difficult when there are quantifiers in
FOL. We refer to the replacement of a constant &quot;a&quot; for the variable &quot;x&quot; when
we write F[a/x].</p>
</li>
<li>
<p><strong>Equality:</strong> Atomic sentences are generated in First-Order Logic not only
through the employment of predicate and words, but also through the
application of equality. We can do this by using equality symbols, which
indicate that the two terms relate to the same thing.</p>
</li>
<li>
<p><strong>FOL inference rules for quantifier:</strong> Because inference rules in
first-order logic are comparable to those in propositional logic, below are
some basic inference rules in FOL:</p>
<ul>
<li>Universal Generalization</li>
<li>Universal Instantiation</li>
<li>Existential Instantiation</li>
<li>Existential introduction</li>
</ul>
</li>
<li>
<p><strong>Universal Generalization:</strong></p>
<ul>
<li>
<p>Universal generalization is a valid inference rule that states that if
premise P(c) is true for any arbitrary element c in the universe of
discourse, we can arrive at the conclusion x P. (x).</p>
</li>
<li>
<p>It can be represented as: <em>formula not visible</em></p>
</li>
<li>
<p>If we want to prove that every element has a similar property, we can
apply this rule.</p>
</li>
<li>
<p>x must not be used as a free variable in this rule.</p>
</li>
<li>
<p><strong>Example:</strong> Let's represent, P(c): &quot;A byte contains 8 bits&quot;, so for ∀ x
P(x) &quot;All bytes contain 8 bits.&quot;, it will also be true.</p>
</li>
</ul>
</li>
<li>
<p><strong>Universal Instantiation:</strong></p>
<ul>
<li>Universal instantiation, often known as universal elimination or UI, is
a valid inference rule. It can be used numerous times to add more
sentences.</li>
<li>The new knowledge base is logically equivalent to the previous one.</li>
<li>We can infer any phrase by replacing a ground word for the variable,
according to the UI.</li>
<li>According to the UI rule, any phrase P(c) can be inferred by
substituting a ground term c (a constant inside domain x) for any object
in the universe of discourse in x P(x).</li>
<li>It can be represented as: <em>formula not visible</em></li>
<li><strong>Example:</strong> IF &quot;Every person like ice-cream&quot;=&gt; ∀x P(x) so we can infer
that &quot;John likes ice-cream&quot; =&gt; P(c)</li>
</ul>
</li>
<li>
<p><strong>Existential Instantiation:</strong></p>
<ul>
<li>Existential Elimination, also known as Existential Instantiation, is a
valid first- order logic inference rule.</li>
<li>It can only be used once to substitute for the existential sentence.</li>
<li>Despite the fact that the new KB is not conceptually identical to the
previous KB, it will suffice if the old KB was.</li>
<li>This rule states that one can infer P(c) from the formula given in the
form of ∃x P(x) for a new constant symbol c.</li>
<li>The only constraint with this rule is that c must be a new word for
which P(c) is true.</li>
<li>It can be represented as:  <em>formula not visible</em></li>
</ul>
</li>
<li>
<p><strong>Existential introduction:</strong></p>
<ul>
<li>An existential generalization, also known as an existential
introduction, is a valid inference rule in first-order logic.</li>
<li>If some element c in the world of discourse has the characteristic P, we
can infer that something else in the universe has the attribute P,
according to this rule.</li>
<li>It can be represented as:  <em>formula not visible</em></li>
<li><strong>Example:</strong> Let's say that, &quot;Pritisha got good marks in English.&quot;
&quot;Therefore, someone got good marks in English.&quot;</li>
</ul>
</li>
<li>
<p><strong>Propositional vs. First-Order Inference:</strong> Previously, inference in first
order logic was checked via propositionalization, which is the act of
turning the Knowledge Base included in first order logic into propositional
logic and then utilizing any of the propositional logic inference mechanisms
to check inference.</p>
</li>
<li>
<p><strong>Key takeaway:</strong></p>
<ul>
<li>In First-Order Logic, inference is used to derive new facts or sentences
from existing ones.</li>
<li>In First-Order Logic, atomic sentences are formed not only via the use
of predicate and words, but also via the application of equality.</li>
<li>There are some Inference rules that can be applied to sentences with
quantifiers to obtain sentences without quantifiers.</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="u1.1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="u1.3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="u1.1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="u1.3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
